package main

import (
	"crypto/tls"
	"encoding/json"
	"encoding/xml"
	"io/ioutil"
	"net"
	"net/http"
	"strings"
	"time"
)

func TimeoutDialer(cTimeout time.Duration, rwTimeout time.Duration) func(net, addr string) (c net.Conn, err error) {
	return func(netw, addr string) (net.Conn, error) {
		conn, err := net.DialTimeout(netw, addr, cTimeout)
		if err != nil {
			return nil, err
		}
		conn.SetDeadline(time.Now().Add(rwTimeout))
		return conn, nil
	}
}

func main() {
	http.HandleFunc("/api/hobo-bff/v0.5/MMMS_Stock", foo)
	http.HandleFunc("/api/hobo-bff/v0.5/MMMS_Request", bar)
	http.ListenAndServe(":3000", nil)
}

func PrettyPrint(i interface{}) string {
	s, _ := json.MarshalIndent(i, "", "\t")
	return string(s)
}
func foo(w http.ResponseWriter, r *http.Request) {
	var sendRes = ""
	connectTimeout := 5 * time.Second
	readWriteTimeout := 19 * time.Second

	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
			Dial:            TimeoutDialer(connectTimeout, readWriteTimeout),
		},
	}
	req, err := http.NewRequest("GET", "http://10.8.4.244:8010/api/material-movement/v1.0/stock?isFRPStock=1", nil)
	req.Header.Add("Authorization", "123")
	resp, err := client.Do(req)

	if err != nil {
		if strings.Contains(err.Error(), "dial tcp") || strings.Contains(err.Error(), "connectex") {
			sendRes = createErrorXml("NoConnect", "", "")
		} else if strings.Contains(err.Error(), "read tcp") {
			sendRes = createErrorXml("NoRequest", "", "")
		} else {
			sendRes = createErrorXml("ExtraException", err.Error(), "")
		}
	} else {
		defer resp.Body.Close()
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			sendRes = createErrorXml("ExtraException", "Can not read body", "")
		} else {
			var result StockStruct
			if err := json.Unmarshal(body, &result); err != nil {
				sendRes = createErrorXml("ExtraException", "Can not unmarshal JSON", "")
			} else {
				if !strings.Contains(string(body), "stocks") {
					sendRes = createErrorXml("NoStocks", "", string(body))
				} else if len(result.Stocks) == 0 {
					sendRes = createErrorXml("EmptyStocks", "", "")
				} else {
					sendRes = createStockXml(result)
				}
			}
		}
	}

	buffer := []byte(sendRes)

	w.Header().Set("Content-Type", "application/xml")
	w.Write(buffer)
}

func bar(w http.ResponseWriter, r *http.Request) {
	var sendRes = ""
	connectTimeout := 5 * time.Second
	readWriteTimeout := 19 * time.Second
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
			Dial:            TimeoutDialer(connectTimeout, readWriteTimeout),
		},
	}
	var result Users

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		sendRes = createErrorXml("ExtraException", "Can not read xml", "")
	} else {
		xml.Unmarshal(body, &result)
	}
	if len(result.Body.GetList.Id2) > 0 {

		req, err := http.NewRequest("GET", "http://10.8.4.244:8010/api/material-movement/v1.0/material-movement-request/1?stockId="+result.Body.GetList.Id2+"&dateFrom=2022-01-01T00:00:00+06:00", nil)
		req.Header.Add("Authorization", "123")
		resp, err := client.Do(req)

		if err != nil {
			if strings.Contains(err.Error(), "dial tcp") || strings.Contains(err.Error(), "connectex") {
				sendRes = createErrorXml("NoConnect", "", "")
			} else if strings.Contains(err.Error(), "read tcp") {
				sendRes = createErrorXml("NoRequest", "", "")
			} else {
				sendRes = createErrorXml("ExtraException", err.Error(), "")
			}
		} else {
			defer resp.Body.Close()
			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				sendRes = createErrorXml("ExtraException", "Can not read body", "")
			} else {
				var result AutoGenerated
				if err := json.Unmarshal(body, &result); err != nil {
					sendRes = createErrorXml("ExtraException", "Can not unmarshal JSON", "")
				} else {
					if !strings.Contains(string(body), "materialMovementRequests") {
						sendRes = createErrorXml("NoStocks", "", string(body))
					} else if len(result.MaterialMovementRequests) == 0 {
						sendRes = createErrorXml("EmptyStocks", "", "")
					} else {
						sendRes = createRequestXml(result, "list")
					}
				}
			}
		}

	} else if len(result.Body.Get.Id2) > 0 {

		req, err := http.NewRequest("GET", "http://10.8.4.244:8010/api/material-movement/v1.0/material-movement-request/"+result.Body.Get.Id2, nil)
		req.Header.Add("Authorization", "123")
		resp, err := client.Do(req)

		if err != nil {
			if strings.Contains(err.Error(), "dial tcp") || strings.Contains(err.Error(), "connectex") {
				sendRes = createErrorXml("NoConnect", "", "")
			} else if strings.Contains(err.Error(), "read tcp") {
				sendRes = createErrorXml("NoRequest", "", "")
			} else {
				sendRes = createErrorXml("ExtraException", err.Error(), "")
			}
		} else {
			defer resp.Body.Close()
			body, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				sendRes = createErrorXml("ExtraException", "Can not read body", "")
			} else {
				var result AutoGenerated
				if err := json.Unmarshal(body, &result); err != nil {
					sendRes = createErrorXml("ExtraException", "Can not unmarshal JSON", "")
				} else {
					if !strings.Contains(string(body), "materialMovementRequests") {
						sendRes = createErrorXml("NoStocks", "", string(body))
					} else if len(result.MaterialMovementRequests) == 0 {
						sendRes = createErrorXml("EmptyStocks", "", "")
					} else {
						sendRes = createRequestXml(result, "get")
					}
				}
			}
		}

	}

	buffer := []byte(sendRes)

	w.Header().Set("Content-Type", "application/xml")
	w.Write(buffer)
}
